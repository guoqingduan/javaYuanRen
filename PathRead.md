/* 正数和负数的
 * 正数的反码与原码相等  正数的补码与原码相等
 * 负数的反码最高位不变其他位取反
 * 负数的补码是反码加1
 * 按位与 & 同为1为1，否则为0
 * 按位或 | 同为0为0  否则为1
 * 异或   ^ 两数相同为0，否则为1
 * 取反   ~
 * 
 */

 /*去掉空白 ctrl+shift+J
 *格式化代码 Ctrl+alt+L
 */
###if和switch的区别
if和switch可以互换，但是if它主要完成的条件判断，switch主要是对数据的结果分支执行，
if可以在条件中书写判断的区间，而switch只能接受固定类型的数据，最后还要求必须是常量
switch（表达式） byte short int char  string（1.7）
###使用switch时需要注意的事项
1.在switch语句中case语句和default语句在书写上没有先后顺序。但是会先执行case语句。
2.switch语句只有遇到两个情况才会结束整个switch语句。1.遇到break语句；2.执行到整个switch语句的
末尾（switch语句匹配的最后的右大括号）
3.在switch语句中，是可以省略default语句的。而且default语句中的break同样也是可以省略的
4.在switch语句的书写上，是可以省略break语句的。但是在执行时，如果没有break语句，程序会向下
  继续执行可执行的代码
###数组的定义：
内存中相同的数据类型的一段连续的存储空间
###数组的特点
长度不可变，存放相同数据类型
###什么是方法重载   
方法名相同，形参不同，返回值和数据类型没有要求
###  
break;不能用于for循环和switch语句之外
continue语句只能用在循环语句中。一般都是与if语句一起使用。
###封装
相同类型的属性和方法的集合，私有化属性，公开化方法
###
内存中的地址用的16进制
###
面向对象(去调用已有的程序)
###
当全局变量和局部变量重名时,优先使用哪一个  优先使用局部变量

实例化对象=创建对象
静态变量和实例变量的区别
书写格式：加不加static的区别
保存位置：static方法区静态域中，实例在堆内存中
生命周期：static：类加载完成就创建，持续到程序结束或者类被卸载
非静态：创建对象的时候分配空间，到被当成垃圾被回收
使用方法：static通过类名使用，非静态通过对象名使用
影响范围：static全局变量类的所有对象，非静态：局部变量，影响当前对象

static优先级
static修饰的方法  
static修饰的变量
static修饰的变量和方法，在类加载时即被初始化，可直接通过类名.变量名和类型.方法名进行调用。
static修饰的方法中不能使用this
静态的只能访问静态的
非静态方法可以访问静态成员和非静态成员
方便在没有创建对象的情况下来进行调用（方法/变量）。
被 static修饰的属性或者是方法 不在属于任何一个对象  而是属于类(class)
static只能在类中创建，不能在方法中
只有static方法才可以用类调用。非static方法只能用对象来调用。
Math.ceil(12.01);向上取整  Math.floor(12.9)向下取整   Math.round(15.02)四舍五入
Arrays.binarySerch(数组,key:要搜索的值);严谨的来说一般使用二分法查找  数组有序并且里面没有重复值
Arrays.copyOfRange(数组,int from,int to);从from到to不包括to   
Arrays.copyOf(数组，长度); Arrays.fill(数组，2);初始化赋值
Arrays.sort(数组); 从小到大；  System.currentTimeMillis();//当前系统时间毫秒值
System.gc();  调用垃圾回收   integer in=Integer.valueOf(str);
int i=Integer.parseInt(str);
Character.isDigit('1');判断字符是否是数字
可以使用BigInteger操作大整数
可以使用BigDecimal指定小数的保留位数
Arrays  俄瑞死   Math 麦死  String 死追ing  copyOfRange  copyOf  sort骚特   currentTimeMillis珂润特
Integer 因特这   Character凯瑞科特  binarySerch 白呢瑞   ceil  sei欧  floor 弗劳额 round rweng的
isDigit  地zhei特  compareTo 科目配额  Ignorecase A个闹K死 concat康卡特 equals 已枯死
replace 若普雷斯   split 斯布里特  substring 撒布死追ing  trim吹母 
                     同一个类   同一个包   不同包的子类  不同包的不同类
public                 yes     yes       yes       yes
protect(受保护的)        yes     yes       yes
default(默认)           yes     yes
private                yes   
子类在方法重写的时候，重写的方法的访问修饰符的权限要大于等于父类的访问修饰符的权限
super(参数列表)；如果不存在那么就会去访问父类的无参构造 不再访问父类的有参构造
this();表示访问当前对象的无参构造   super();和this();在构造函数里面只能是第一行的位置
super  表示父类对象在内存中所在的位置  this 表示当前对象在内存中所在的位置
创建子类对象的时候优先去访问父类的构造函数 原因是因为子类要用到父类的成员
构造函数不是继承的 而是通过super()去访问的
子类不能继承父类私有化成员和构造函数
虽然使用extends关键字可以在任意两个类之间建立继承关系。但是在实际开发中，一般只有两个类有一种关系的时候，才使用继承。
关系就是：子类描述的事物  是  父类描述事物的一个特例；
方法重写：子类方法和父类方法一致（方法名一致 参数列表一致 返回值类型一致）具体实现功能不一样
final修饰的类不能被继承，修饰的变量，变量变常量，并且要有初始值，不支持修改。修饰方法：可以被子类继承，但是不能被子类重写
当final修饰局部变量时，当修饰引用对象时，对象地址不能变，其成员的属性值可以变
多态的实现：1。要有继承 2.发生方法重写 3。父类引用指向子类
static修饰的方法不属于多态，也不能重写
多态是针对相同的行为，和数据类型无关。成员变量看左边，成员方法看右边。
简化代码，增加代码的扩展性，减少类和类之间的关联
抽象类里面的方法 可以有抽象方法   可以有普通方法  也可以有静态方法
接口里面的方法在jdk1.8之前都是抽象方法
1.8之后可以有默认方法
接口可以多实现（多继承） 普通类和抽象类不能有多继承。  接口里面的变量是常量
常量在java编译期就确定所有的常量放在常量池中。
静态内部类中可以有非静态方法
内部类中的方法如果是静态的那么这个类一定是静态内部类
如果一个对象里面的方法只被使用一次  那么我们可以使用匿名内部类的方式





















